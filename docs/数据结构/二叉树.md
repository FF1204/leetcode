# 二叉树

树是没有环的图。树和链表、图都有关联。链表是树的一种特殊情况，而图都可以对应一棵生成树。学习完链表，学习树，然后学习图，是一个比较容易接受的过程。每个节点最多有两个子节点的树叫做二叉树。二叉树是递归定义的，这导致很多涉及二叉树的问题都可以用递归的方法求解。按照节点数目的不同，二叉树的类型有：完全二叉树，满二叉树和完美二叉树。

## 二叉树的通用性质

- 二叉树的第i层节点数目至多是`2^(i-1); (i>=1)`
- 深度为K的二叉树至多有`2^(K-1)`个节点。
- 二叉树中出度为2的节点数目记作n2, 叶节点记作n0; 则有`n0 = n2 + 1`
- 深度为n的完美二叉树，其节点的数目是`2^n -1`, 叶节点数目是`2^(n-1)`, 非叶节点的数目是`2^(n-1)-1`
- 节点数目为n的完美二叉树，深度是`log2(n+1)`
- 节点数目为n的完全二叉树，深度是`[log2(n)] + 1`  其中[]表示向下取整

## 二叉树的定义

二叉树的结构和双向链表比较相似，需要两个指针分别指向左孩子和右孩子。

```c
// 定义二叉树的结构
class TreeNode {
public:
   int val;
   TreeNode *left, *right;
   TreeNode(int val) {
       this->val = val;
       this->left = this->right = nullptr;
   }
}
```

## 二叉树的创建(生成)

创建一棵二叉树有多种方式，算法中指定二叉树通常使用"#"表示不存在的节点，这里我们采用两个遍历序列的方式来确定一棵二叉树的结构。前序遍历序列和中序遍历序列可以唯一的确定一颗二叉树的结构，后序遍历序列和中序遍历序列也可以唯一的确定一棵二叉树的结构。

### 根据前序遍历和中序遍历重建二叉树

根据二叉树的前序遍历和中序遍历的结果创建二叉树，根据前序遍历序列和中序遍历序列可以唯一的确定一棵二叉树。
假设前序遍历的序列是pre; 中序遍历的序列是vin;里面都不含有重复数字；首先确定根节点，肯定是pre[0], 然后在vin中寻找pre[0], 它前面的一定是左子树上的，后面的都是右子树上的。假设pre[0]出现在vin[3],可以知道左子树上有三个节点，分别是vin[0],vin[1],vin[2], 在pre中从pre[0]以后数3个数字这三个数字一定是位于左子树上的，剩下的属于右子树。分别按照上面的方法递归处理左右子树，直到只剩下一个元素，返回答案；举例来说，假设`pre = [1,2,4,7,3,5,6,8] `   `vin=[4,7,2,1,5,3,8,6]`第一次： 可知1是根，2，4，7是1的左子树上的，3,5,6,8,是1的右子树上的。 分别处理序列`[2,4,7] [4,7,2]` 和` [3,5,6,8] [5,3,6,8]`第二次： 对于`[2,4,7] [4,7,2]` 可以得到2是根，而4，7都是左子树上的， 接着处理`[4,7] [4,7]` 此时4是根，而7位于右子树上，这边处理完毕；对于`[3,5,6,8] [5,3,8,6]` 可以得到3是根，5是左子树上的，`[6,8]`是右子树上的。接着处理`[6,8][8,6]` 此时6是根，而8位于左子树上。

综合上面的分析，可以得到这个二叉树的形状如下：

![](img\tree_buildtree.svg)

```c
//根据前序遍历和中序遍历重建二叉树
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty() || vin.empty()){return nullptr;}
        TreeNode* node = new TreeNode(pre[0]);// 先建立根节点
        int len = pre.size();
        for(size_t i=0;i<vin.size();++i){
            if(vin[i] == pre[0]){
                // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。
                vector<int> left_pre(i,0);
                vector<int> left_vin(i,0);
                vector<int> right_pre(len-1-i,0);
                vector<int> right_vin(len-1-i,0);
                copy(vin.begin(),vin.begin()+i,left_vin.begin());
                copy(vin.begin()+i+1,vin.end(),right_vin.begin());
                copy(pre.begin()+1,pre.begin()+1+i,left_pre.begin());
                copy(pre.begin()+i+1,pre.end(),right_pre.begin());
                node->left =  reConstructBinaryTree(left_pre,left_vin);
                node->right = reConstructBinaryTree(right_pre,right_vin);
            }

        }
        return node;
```

[leetcode](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/#/description)  [gist](https://gist.github.com/FF120/8c0508c1412cf1ca486dc10695ea1c94)

### 根据后序遍历和中序遍历重建二叉树

```c
//后序遍历和中序遍历重建二叉树
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    if (inorder.empty() || postorder.empty()) { return nullptr; }
    TreeNode *node = new TreeNode(postorder[postorder.size()-1]);// 先建立根节点
    int len = inorder.size();
    for (size_t i = 0; i < inorder.size(); ++i) {
        if (inorder[i] == postorder[postorder.size()-1]) {
            // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。
            vector<int> left_post(i, 0);
            vector<int> left_vin(i, 0);
            vector<int> right_post(len - 1 - i, 0);
            vector<int> right_vin(len - 1 - i, 0);
            copy(inorder.begin(), inorder.begin() + i, left_vin.begin());
            copy(inorder.begin() + i + 1, inorder.end(), right_vin.begin());
            copy(postorder.begin(), postorder.begin() + i, left_post.begin());
            copy(postorder.begin() + i, postorder.end()-1, right_post.begin());
            node->left = buildTree(left_vin,left_post);
            node->right = buildTree(right_vin,right_post);
        }
    }
    return node;
}
```

[leetcode](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/#/description)  [gist](https://gist.github.com/FF120/86ed96f2c2a7c110119e191ddcc94cd8)

## 二叉树的深度

从根节点到叶节点经过的节点数量定义为二叉树的深度。

### 最大深度

```c
 // 二叉树的最大深度
int maxDepth2(TreeNode *root, const int dep){
    if(!root) return dep;
    if(!root->left && !root->right) return dep+1;
    if(root->left && !root->right) return maxDepth2(root->left,dep+1);
    if(root->right && !root->left) return maxDepth2(root->right,dep+1);     
    return max(maxDepth2(root->left,dep+1),maxDepth2(root->right,dep+1));   
}
```

### 最小深度

```c
// 二叉树的最小深度
int minDepth2(TreeNode* root,const int dep){
    if(!root) return dep;
    if(!root->left && !root->right) return dep+1;
    if(root->left && !root->right)  return minDepth2(root->left,dep+1);
    if(!root->left && root->right)  return minDepth2(root->right,dep+1);
    return min(minDepth2(root->left,dep+1),minDepth2(root->right,dep+1));
}
```

## 二叉树的遍历

二叉树有三种常见的遍历方式：前序遍历、中序遍历、后序遍历。前中后指的都是根节点相对于左右孩子节点的顺序。所以前序遍历的顺序是 `root-left-right`, 中序遍历的顺序是 `left-root-right`, 后序遍历的顺序是 `left-right-root`. 

### 前序遍历(递归)

**前序遍历遍历的步骤**：

1. 输出当前节点
2. 如果有左孩子，用左孩子做参数递归
3. 如果有右孩子，用由孩子做参数递归

```c
// 前序遍历
 vector<int> preorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        re.push_back(root->val);
        if(root->left){
            vector<int> ll = preorderTraversal(root->left);
            re.insert(re.end(), ll.begin(), ll.end());
        }
        if(root->right){
            vector<int> rr = preorderTraversal(root->right);
            re.insert(re.end(), rr.begin(), rr.end());
        }
        return re;
    }
```

### 前序遍历(非递归)

非递归的实现，递归函数的实现是使用堆栈的方式，所以把递归调用的函数改写成非递归的形式一般也是使用堆栈作为数据结构。

**前序遍历的非递归遍历步骤**

1. 输出当前的节点值，并把当前的节点压入栈
2. `current = current->left`;循环以上步骤直到没有左孩子，执行下面的步骤
3. 取栈顶元素的右孩子，弹出栈顶元素，然后回到步骤1.

```c
//前序遍历的非递归实现
vector<int> preorderTraversal(TreeNode *root) {
	vector<int> re;
	 if(root == nullptr) return re;
	 stack<TreeNode*> s;
	 TreeNode *tmp = root;
	 while(tmp!=nullptr || !s.empty()){ // 逻辑或是短路的
		while(tmp!=nullptr){
			re.push_back(tmp->val);
			s.push(tmp);
			tmp = tmp->left;
		}
		// 循环退出说明没有了左孩子
		if(!s.empty()){
		   tmp = s.top();
		   s.pop();
		   tmp = tmp->right;
		}
	 }
	 return re;
}
```

### 中序遍历(递归)

**中序遍历遍历的步骤**

1. 如果当前的节点有左孩子，用左孩子作为参数递归
2. 输出当前节点
3. 如果当前节点有右孩子，用右孩子作为参数递归

```c
// 中序遍历的递归实现
vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = inorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        re.push_back(root->val);
        if(root->right){
            vector<int> rr = inorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        return re;
    }
```

### 中序遍历(非递归)

**中序遍历的非递归实现**

1. 对于当前的节点，放入堆栈，然后搜索有没有左孩子，一直向下搜索到没有左孩子为止。
2. 从堆栈取出栈顶元素，输出，然后搜索右孩子

```c
//中序遍历的非递归实现
 vector<int> inorderTraversal(TreeNode * root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        
        TreeNode* iter = root;
        stack<TreeNode*> s;
        
        while(iter || !s.empty()){
            while(iter){
                s.push(iter);
                iter = iter->left;
            }
            if(!s.empty()){
                iter = s.top();
                s.pop();
                re.push_back(iter->val);
                iter = iter->right;
            }
        }
        
        return re;
    }
```

### 后序遍历(递归)

**后序遍历遍历的步骤是**

1. 如果当前节点有左孩子，用左孩子作为参数递归
2. 如果当前节点有右孩子，用右孩子作为参数递归
3. 输出当前节点

```c
// 后续遍历的递归实现
 vector<int> postorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = postorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        if(root->right){
            vector<int> rr = postorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        re.push_back(root->val);
        return re;
    }
```

### 后序遍历(非递归)

**后序遍历的非递归实现**

第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。

```c
//后序遍历的非递归实现

```

第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。

```c
// 后序遍历的非递归实现
vector<int> postOrder(TreeNode *root)
{
    vector<int> re;
    if(root == nullptr) return re;

    TreeNode *p = root;
    stack<TreeNode *> s; 
    TreeNode *last = root;
    s.push(p);
    while (!s.empty())
    {
        p = s.top();
        if( (p->left == nullptr && p->right == nullptr) || (p->right == nullptr && last == p->left) || (last == p->right) )
        {
            re.push_back(p->val);
            last = p;
            s.pop();
        }
        else
        {
            if(p->right)
                s.push(p->right);
            if(p->left)
                s.push(p->left);
        }
    }
    return re;
}

```

### 层次遍历

二叉树的层次遍历类似与图的广度优先搜索，可以使用队列来实现。思路是： 使用两个队列保存相邻两层的节点，循环输出每层的节点

**层次遍历遍历的步骤**

> 1. 初始化两个队列d1,d2;令d1保存root,d2为空
> 2. 清空d2,遍历d1中的节点，把d1中节点的所有孩子节点按照顺序放入d2中
> 3. 打印d1中的节点
> 4. 交换d1和d2;转到2
> 
> 循环直到d2中为空，结束。

```c
// 从底向上层次遍历二叉树
 vector<vector<int>> levelOrderBottom(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        vector<TreeNode*> v1,v2;
        if(root == nullptr){
            return result;
        }
        v1.push_back(root);
        while(!v1.empty()){
            // 遍历v1中的所有节点，将下一层节点保存在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            vector<int> tmp;
            //打印v1
            for(int i=0;i<v1.size();i++){
                tmp.push_back(v1[i]->val);
            }
            result.insert(result.begin(),tmp);
            swap(v1,v2);
            v2.clear();
        }
        return result;
 }
```

```c
// 自顶向下遍历二叉树
 vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        if(!root) return result;
        vector<TreeNode*> v1,v2;
        v1.push_back(root);
        int level = 1;
        while(!v1.empty()){
            //遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            // 打印v1中的节点,如果level 是奇数，则从左向又打印，
            // 如果level是偶数，则从右向左打印
            vector<int> tmp;
            if(level % 2 == 0){
                for(int i=v1.size()-1;i>=0;i--){
                    tmp.push_back(v1[i]->val);
                }
            }
            if(level % 2 ){
                for(int i=0;i<v1.size();i++){
                    tmp.push_back(v1[i]->val);
                }
            }
            result.push_back(tmp);
            // 更新该更新的数据
            swap(v1,v2);
            v2.clear();
            level++;
        }
        return result;
    }
```

```c
// 之字形遍历二叉树
vector<vector<int> > Print(TreeNode* pRoot) {
    vector<vector<int> > output;
    vector<int> row;
    if(pRoot == nullptr) return output;
    vector<TreeNode*> first;
    vector<TreeNode*> second;
    bool odd = true;
    first.push_back(pRoot);
    while(!first.empty()){
        if(odd){
            for (int i = 0; i < first.size(); ++i) {
                row.push_back(first[i]->val);
                if(first[i]->left){
                    second.push_back(first[i]->left);
                }
                if(first[i]->right){
                    second.push_back(first[i]->right);
                }
            }
            output.push_back(row);
            row.clear();
            swap(first,second);
            second.clear();
            odd = !odd;
        }else{
            for (int i = first.size()-1; i >= 0; --i) {
                row.push_back(first[i]->val);
            }
            output.push_back(row);
            row.clear();
            for (int j = 0; j < first.size(); ++j) {
                if(first[j]->left){
                    second.push_back(first[j]->left);
                }
                if(first[j]->right){
                    second.push_back(first[j]->right);
                }
            }
            swap(first,second);
            second.clear();
            odd = !odd;
        }
    }
    return output;
}
```

## 平衡二叉树

平衡二叉树的定义是：要么是一棵空树，要么根节点左右两棵子树的高度相差不超过1，并且左右两个子树也是平衡二叉树。

### 平衡二叉树的判定

```c
// 求树的最大深度
int maxDepth(TreeNode* root) {
    if(root == nullptr) return 0;
    int left = 1;
    int right = 1;
    int depth = 1;
    if(root->left){
        left += maxDepth(root->left);
    }
    if(root->right){
        right += maxDepth(root->right);
    }
    depth = max(left,right);
    return depth;
}
// 判断二叉树是否是平衡二叉树
bool isBalanced(TreeNode* root) {
    if(root == nullptr) return true;
    if(root->left == nullptr && root->right == nullptr) return true;
    if(root->left && root->right == nullptr){
        if(root->left->left== nullptr && root->left->right == nullptr){
            return true;
        }
        return false;
    }
    if(root->left == nullptr && root->right){
        if(root->right->left == nullptr && root->right->right == nullptr){
            return true;
        }
        return false;
    }
    bool left = isBalanced(root->left);
    bool right = isBalanced(root->right);
    int ldepth = maxDepth(root->left);
    int rdepth = maxDepth(root->right);
    if(abs(ldepth-rdepth)<=1 && left && right) return true;
    return false;
}
```

## 二叉搜索树(二叉查找树)

二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

>- 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
>- 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
>- 任意结点的左、右子树也分别为二叉查找树。
>- 没有键值相等的结点（no duplicate nodes）。

因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）.（至于n个结点的二叉树高度为lgn的证明，可参考算法导论 第12章 二叉查找树 第12.4节）。

但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。后面我们会看到一种基于二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为O（lgn）。

### 二叉搜索树的基本操作

```python
class BinaryTree():
    def __init__(self, parent=None, left=None, right=None):
        self.parent = parent
        self.left = left
        self.right = right
        self.value = value

def insert(root, value):
    if not root:
        root = Node(value)
        return root
    if root.value == value:
        return root
    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)
    return root

def search(root, value):
    if not root:
        return None
    if root.value == value:
        return root
    if value < root.value:
        return search(root.left, value)
    else:
        return search(root.right, value)

def delete(root, value):
    if root is None:
        return root
    if value < root.value:
        root.left = delete(root.left, value)
    elif value > root.value:
        root.right = delete(root.right, value)
    else:
        if root.left is None and root.right is None:
            return None
        if root.left is None:
            tmp = root.right
            root = None
            return tmp
        if root.right is None:
            tmp = root.left
            root = None
            return tmp
        current = root.right
        currentParent = None
        while current.left is not None:
            currentParent = current
            current = current.left
        currentParent.left = current.right
        root.value = current.value
    return root

def build(array):
    tree = None
    for v in array:
        tree = insert(tree, v)
    return tree

def max(root):
    if root is None:
        return None
    current = root
    while current.right is not None:
        current = current.right
    return current.value

def min(root):
    if root is None:
        return None
    current = root
    while current.left is not None:
        current = current.left
    return current.value

# 查找比node节点小的节点
def pre(node):
    if node is None:
        return None
    if node.left is not None:
        tmp = node.left
        while tmp.right is not None:
            tmp = tmp.right
        return tmp
    parent = node.parent
    current = node
    while parent is not None and parent.left == current:
        parent = parent.parent
        current = parent
    return parent

def next(node):
    if node is None:
        return None
    if node.right is not None:
        tmp = node.right
        while tmp.left is not None:
            tmp = tmp.left
        return tmp
    parent = node.parent
    current = node
    while parent is not None and parent.right == current:
        parent = parent.parent
        current = parent
    return parent
```

### 二叉搜索树的遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

```c
// 思路：如果是二叉搜索树的后序遍历序列，那么最后一个一定是根，并且一定可以存在这样的关系：根前面的元素分成两部分，前一部分都比根小，后一部分都比根大，注意，这里前一部分和后一部分都可能为空。判断给出的序列是否满足这样的规律，然后分别递归判断左右两个分支。
bool bst(vector<int> &a,int l,int r){
       // 1. 找到第一个比根(r)小的元素，这里作为左右子树的分界
       if(l>=r) return true;
       int i=r-1;
       while(i>=l && a[i]>a[r]){
           --i;
       }
       // 此时i指向从后向前第一个小于a[r]的元素
       // 2. 检查从i到l的所有元素是否都小于a[r]
       int mid = i;
       while(i>=l){
           if(a[i] >= a[r]){
               return false;
           }
           i--;
       }
       // 此时 i应该等于l-1
       // 3. 划分出左右子树并且确保符合二叉搜索树的要求，递归左右子树，看是否符合要求
       return bst(a,l,mid) && bst(a,mid+1,r-1);

   }
   bool VerifySquenceOfBST(vector<int> sequence) {
   if(sequence.empty()) return false;
       return bst(sequence,0,sequence.size()-1);
   }
```
## 堆

堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。

既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是`i`,那么它的左孩子为`2*i`,右孩子为`2*i+1`,父节点为`i/2`. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1.

如果根节点是从0开始标号的，那么对于节点`i`, 左孩子为`2*i+1`,右孩子为`2*i+2`,父节点为`(i-1)/2`.

![](img\2017-04-11_091249.png)

```c 
// 根节点从0开始标号，对于节点i，求其左孩子，右孩子和父节点
inline int left(int i){
    return (i<<1) + 1;
}
inline int right(int i){
    return (i<<1) + 2;
}
inline int parent(int i){
    if(i == 0) return -1;
    return (i-1) >> 1;
}
```

### 最大堆

最大堆就是满足父节点大于等于子节点的堆。最大堆的根节点是所有元素中最大的(但可能不是唯一的最大的，注意这里是大于等于)。

#### 调整最大堆

假设`A`是存储堆的数组,`A.length()`表示数组的大小，`heap_size`表示堆中元素的个数, 满足`heap_size <= A.length()`.假设我们需要调整节点`i`以使得堆重新满足最大堆的性质(注意这个时候只有节点i是不满足最大堆的性质的)，步骤如下：

1. 找出节点`i`的左右孩子`l`,`r`;
2. 如果`l`,`r`超过了堆的大小，直接返回，如果A[i]大于等于`l`,`r`,直接返回
3. 找到`l`,`r`中的较大者,记为`maxIndex`，和`A[i]`交换
4. 令i = maxIndex, 转到1。

```c
/**
 * 调整节点i,使得整个堆保持最大堆的性质
 * @param A
 * @param i
 */
void max_heap(vector<int> &A,int i){
    int heap_size = A.size();
    // 不存在这个样的节点（节点从0开始编号）
    if(i >= heap_size || i < 0) return;
    auto l = left(i);
    auto r = right(i);
    // 如果没有孩子节点了，不需要调整了
    if(l >= heap_size ) return;
    int maxIndex = -1;
    if(r >= heap_size ){
        if(A[i] >= A[l]) return;
        maxIndex = l;
    }else{
        // 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整
        if(A[i] >= A[l] && A[i] >= A[r]) return;
        // 找到两个孩子节点中较大的那一个
        A[l] >= A[r] ? maxIndex = l : maxIndex = r;
    }
    swap(A[i],A[maxIndex]);
    max_heap(A,maxIndex);
}
```

```c
/**
 * 调整节点i,使得整个堆保持最小堆的性质
 * @param A 
 * @param i 
 */
void min_heap(vector<int> &A,int i){
    int heap_size = A.size();
    // 不存在这个样的节点（节点从0开始编号）
    if(i >= heap_size || i < 0) return;
    auto l = left(i);
    auto r = right(i);
    // 如果没有孩子节点了，不需要调整了
    if(l >= heap_size ) return;
    int minIndex = -1;
    if(r >= heap_size ) {
        if(A[i] <= A[l]) return;
        minIndex = l;
    }else{
        // 如果节点i比它两个孩子节点都小，则满足最小堆的性质，不用调整
        if(A[i] <= A[l] && A[i] <= A[r]) return;
        // 找到两个孩子节点中较大的那一个
        A[l] <= A[r] ? minIndex = l : minIndex = r;
    }
    swap(A[i],A[minIndex]);
    min_heap(A,minIndex);
}
```

#### 建堆

如何从一个无序的数组建立一个堆是堆操作中一个基本的，但很重要的问题，它通常是很多问题的第一步。

根据完全二叉树的性质，一个包含n个元素的数组形成的完全二叉树中，n - ([n/2] + 1) + 1个元素是叶子节点。我们只需要针对所有的叶子节点之外的节点调用上面的重建堆的函数，就可以构建一个最大堆。 时间复杂度是O(n).

```c
/**
 * 从无序数组建立最大堆
 * @param A
 */
void build_max_heap(vector<int> &A){
    int leaf = A.size() / 2 ;
    for (int i = leaf - 1; i >= 0 ; --i) {
        max_heap(A,i);
    }
}
```

```c
/**
 * 从无序数组建立最小堆
 * @param A
 */
void build_min_heap(vector<int> &A){
    int leaf = A.size() / 2;
    for (int i = leaf - 1; i >= 0 ; --i) {
        min_heap(A,i);
    }
}
```

### 堆排序

堆排序就是利用堆的结构来维护最大值或者最小值实现排序的一种算法，这里以最大堆为例来说明。 首先把无序数组重建一个最大堆，使用上面提到的函数，这一步可以轻松的在O(n)的时间复杂度内完成。 此时A[0]存储的是这个数组的最大值，将它与数组的最后一个元素交换位置，然后堆的长度减少1，也就是数组的最后一个元素不再当作堆的元素，因为它已经在正确的位置上了，然后调整堆使之符合最大堆的性质。 重复这个步骤直到所有的元素放到了正确的位置之上。

```c
void max_heap(vector<int> &A,int heap_size,int i){
    // 不存在这个样的节点（节点从0开始编号）
    if(i >= heap_size || i < 0) return;
    auto l = left(i);
    auto r = right(i);
    // 如果没有孩子节点了，不需要调整了
    if(l >= heap_size ) return;
    int maxIndex = -1;
    if(r >= heap_size ){
        if(A[i] >= A[l]) return;
        maxIndex = l;
    }else{
        // 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整
        if(A[i] >= A[l] && A[i] >= A[r]) return;
        // 找到两个孩子节点中较大的那一个
        A[l] >= A[r] ? maxIndex = l : maxIndex = r;
    }
    swap(A[i],A[maxIndex]);
    max_heap(A,heap_size,maxIndex);
}

void build_max_heap(vector<int> &A){
    int leaf = A.size() / 2 ;
    for (int i = leaf - 1; i >= 0 ; --i) {
        max_heap(A,A.size(),i);
    }
}

void sort_with_max_heap(vector<int> &v){
    build_max_heap(v);
    int heap_size = v.size();
    while(heap_size){
        swap(v[0],v[heap_size-1]);
        heap_size--;
        max_heap(v,heap_size,0);
    }
}
```

堆排序的时间性能是nlogn,但是实际使用的时候，快速排序的性能更好一些，一般情况下都是使用快速排序。

### 优先队列

优先队列是能够`快速`的完成以下操作的数据结构：

1. 返回最大值
2. 返回最大值并删除该元素
3. 将任意一个已在优先队列中的元素增加k.
4. 插入一个任意值


能够维护一个数据结构，快速的实现以上所有操作的叫做优先队列。使用堆来实现优先队列，可以保证所有的操作都可以在`o(lgn)`完成。

1. 返回最大值

使用最大堆实现优先队列这种结构，直接返回`A[0]`就是最大值。

2. 返回最大值并删除该元素

首先输出`A[0]`, 然后把最后一个元素赋值给`A[0]`,调整堆使之符合最大堆性质。

```c
int maxP(vector<int> &A){
    int maxV = A[0];
    A[0] = A[A.size()-1];
    int heap_size = A.size()-1;
    max_heap(A,heap_size,0);
    return maxV;
}

```

## AVL树

定义节点的平衡因子为 左子树的高度 - 右子树的高度， AVL树是满足所有节点的平衡因子都小于等于1的二叉搜索树。

如果插入，删除操作比较少， 查询操作比较多， 使用AVL树； 如果插入删除操作很频繁，使用红黑树，因为红黑树的插入删除效率高。

```python
def get_height(node):
    if node is None:
        return 0
    return node.height
def get_balance(node):
    if node is None:
        return 0
    balance = get_height(node.left) - get_height(node.right)
    return balance
def left_rotate(node):
    node_right = node.right
    node_right_left = node_right.left
    # 左旋
    node_right.left = node
    node.right = node_right_left
    # 更新高度
    node_left_height = get_height(node.left)
    node_right_height = get_height(node.right)
    root.height = 1 + max(node_left_height, node_right_height)
    # 返回旋转之后新的根
    return node_right
def right_rotate(node):
    node_left = node.left
    node_left_right = node_left.right
    # 右旋
    node_left.right = node
    node.left = node_left_right

    node_left_height = get_height(node.left)
    node_right_height = het_height(node.right)
    node.height = 1 + max(node_left_height, node_right_height)

    return node_left
def insert(root, value):
    if root is None:
        root = Node(value)
        return root
    if value == root.value:
        return root
    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)

    # 插入完成之后调整
    left_height = get_height(root.left)
    right_height = get_height(root.right)
    root.height = 1 + max(left_height, right_height)
    balance = get_balance(root)
    # LL type
    if balance > 1 and value < root.left.value:
        return right_rotate(root)
    # RR type
    if balance < -1 and value > root.right.value:
        return left_rotate(root)
    # LR type
    if balance > 1 and value > root.left.value:
        return right_rotate(root)
    # RL type
    if balance < - 1 and value < root.right.value:
        return  left_rotate(root)
def delete(root, value):
    if root is None:
        return root
    if value < root.value:
        root.left = delete(root.left, value)
    elif value > root.value:
        root.right = delete(root.right, value)
    else:
        if root.left is None and root.right is None:
            return None
        if root.left is None:
            tmp = root.right
            root = None
            return tmp
        if root.right is None:
            tmp = root.left
            root = None
            return tmp
        current = root.right
        currentParent = None
        while current.left is not None:
            currentParent = current
            current = current.left
        currentParent.left = current.right
        root.value = current.value
    if root is None:
        return root
    root.height = 1 + max(get_height(root.left), get_height(root.right))
    balance = get_balance(root)
    # LL
    if balace > 1 and get_balance(root.left) >= 0:
        return right_rotate(root)
    # LR
    if balance > 1 and get_balance(root.left) < 0:
        root.left = left_rotate(root.left)
        return right_rotate(root)
    # RR
    if balance < -1 and get_balance(root.right) <= 0:
        return left_rotate(root)
    # RL
    if balance < -1 and get_balance(root.right) > 0:
        root.right = right_rotate(root.right)
        return left_rotate(root)
    return root
```

## 红黑树

参考文章：http://blog.csdn.net/chenhuajie123/article/details/11951777
红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)

红黑树的性质：

> 1. 每个结点要么是红的，要么是黑的。
> 2. 根结点是黑的。
> 3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
> 4. 如果一个结点是红的，那么它的俩个儿子都是黑的。
> 5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。

红黑树的示例：

![2017-04-11_094148.png](img\tree_redblacktree.png)

## 树状数组

树状数组是一个能够快速完成下术操作的数据结构：

> - 给定一个初始值全为0的数列，a1,a2,a3,a4,...an
> - 给定i,计算a1+a2+...+ai
> - 给定i和x,计算ai = ai + x;

<!-- more -->

上面提到的线段树其实已经满足了上面的要求，只不过有些(大材小用了)。可以用更简单的结构实现这个要求。

![2017-04-12_161624.png](img\tree_treearray.png)

把线段树所有的右节点去掉，只剩下左节点，然后对应的位置不变，投射到最下面一行，就形成了树状数组的结构。例如8个元素的树状数组的结构是：

|A[1]|A[2]|A[3]|A[4]|A[5]|A[6]|A[7]|A[8]|
|---|---|---|---|---|---|---|---|---|
|1|[1,2]|3|[1,4]|5|[5,6]|7|[1,8]|
|0001|0010|0011|0100|0101|0110|0111|1000|

有了上面的结构，如果想求`c[3]+c[4]+c[5]`就是`A[4]-A[2]+A[5]`;
如果想求`c[4]`,就是`A[4]-A[3]-A[2]`; 总之，一个区间内的和总可以在常数时间内通过树状数组中的值求出来。树状数组可以使用位来保存，通过寻找其中的规律，可以使用简单的位操作实现树状数组的求和和更新。上面表格的最后一行是对树状数组A进行的二进制的编码。
求树状数组的前i项和：

|i|表达式|二进制表示|
|--|--|--|
|1|A[1]|0001|
|2|A[2]|0010|
|3|A[3]+A[2]|0011+0010|
|4|A[4]|0100|
|5|A[5]+A[4]|0101+0100|
|6|A[6]+A[4]|0110+0100|
|7|A[7]+A[6]+A[4]|0111+0110+0100|
|8|A[8]|1000|

从二进制当中寻找规律，求前i项：

> 1. 初始化sum=0;
> 2. 从树状数组A[i]开始，把A[i]加入到结果中去。然后从i中减去i最低位1对应的数字。i的最低位的1对应的数字的值的大小可以用`i&(-i)`求得。
> 3. 直到i的结果为0停止。

按照上面的步骤分析上面表格中的每一行的求解：

>- 0001减去最后一位二进制1对应的数字（1）之后为0，所以最后结果是A[1]
>- 0010减去最后一位二进制1对应的数字(2)之后为0，所以最后的结果是A[2]
>- 0011减去最后以为二进制1对应的数字(1)之后为(0010,A[2]),而0010减去最后一位二进制1对应的数字(2)之后为0,所以最后的结果是A[3]+A[2]
>- 0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[4]
>- 0101减去最后以为二进制1对应的数字(1)之后为0100,0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[5]+A[4]
>- 0110 = 0110 + 0100 = A[6] + A[4]
>- 0111 = 0111 + 0110 + 0100 + A[7] + A[6] + A[4]
>- 1000 = 1000 = A[8]

上面就是BIT数组求和的详细解释，了解了这个过程，在知道如何求解一个数字最低位1对应的值，实现BIT的求和应该不难。下面看看BIT如何更新。
假如我们想更新c[2]的值，那么A中所有包含c[2]的值都可能发生变化，到底哪些值包含c[2]呢？从上面的表格我们看出，包含c[2]的A元素有A[2],A[4],A[8];下面再列一个表格，显示每个元素的更新都涉及哪些元素，这样就比较容易找到其中的规律。

|更新的值|涉及的BIT|二进制表示|
|--|--|--|
|c[1]|A[1],A[2],A[4],A[8]|0001,0010,0100,1000|
|c[2]|A[2],A[4],A[8]|0010,0100,1000|
|c[3]|A[3],A[4],A[8]|0011,0100,1000|
|c[4]|A[4],A[8]|0100,1000|
|c[5]|A[5],A[6],A[8]|0101,0110,1000|
|c[6]|A[6],A[8]|0110,1000|
|c[7]|A[7],A[8]|0111,1000|
|c[8]|A[8]|1000|

可以看到，更新的时候和求和的时候顺序似乎相反，规律是：如果要更新c[i],那么就从i开始，更新A[i]之后将i更新为`i = i+(i&(-i))`,直到最后一个元素为止。因为无论更新哪个元素，最后一个元素包含所有值的和，所以必须更新最后一个元素。`i&(-i)`是得到i的最后一位二进制1对应的数值的大小，然后加到i上，对比上面的表格。i的更新情况是：

> - 0001(1)-0001+0001(2)-0010+0010(4)-0100+0100(8)=1000 停止
> - 0010(2)-0010+0010(4)-0100+0100(8)=1000 停止
> - 0011(3)-0011+0001(4)-0100+0100(8)=1000 停止
> - 0100(4)-0100+0100(8)=1000 停止
> - 0101(5)-0101+0001(6)-0110+0010(8)=1000 停止
> - 0110(6)-0110+0010(8)=1000 停止
> - 0111(7)-0111+0001(8)=1000 停止
> - 1000(8) = 1000 停止

树状数组的实现：

```c
#include <iostream>
#include <vector>
using namespace std;
class BIT{
public:
    vector<int> v;
    int n;
    BIT(){}
    // 构建n个元素的空树状数组
    BIT(int num){
        n = num+1; // v[0]不用，下标从1开始。
       for(int i=0;i<n;i++){
           v.push_back(0);
       }
    }
    //求前i项的和
    int sum(int i){
        int s = 0;
        while(i>0){
            s += v[i];
            i -= i & (-i);
        }
        return s;
    }
    //第i 项加上x
    void add(int i,int x){
        while(i<=n){
           v[i] += x;
            i += i&(-i);
        }
    }
    //根据传入的数组c构建它的树状数组
    void create(vector<int> &c){
        for(int i=0;i<c.size();i++){
            add(i+1,c[i]);
        }
    }

};
void printV(vector<int> a){
    for(auto aa:a){
        cout<<aa<<" ";
    }
    cout<<endl;
}
int main() {
    vector<int> c = {3,7,6,5,4,2,8,1};
    BIT *b = new BIT(c.size());
    b->create(c);
    printV(b->v);
    b->add(8,10);
    printV(b->v);
    b->add(1,1);
    printV(b->v);
    return 0;
}
```

运行结果：

```
0 3 10 6 21 4 6 8 36
0 3 10 6 21 4 6 8 46
0 4 11 6 22 4 6 8 47
```

可以看到，树状数组仅仅使用位操作就可以实现求和和更新，比线段树的开销要少很多，所以，一些能用树状数组解决的问题，不宜使用线段树。

参考博文：

http://www.cnblogs.com/wuwangchuxin0924/p/5921130.html
http://www.cnblogs.com/GeniusYang/p/5756975.html

## 线段树[区间树]

线段树是一棵二叉树，他的每个节点包含了两个额外的属性`start`和`end`用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:

根节点的 `start` 和 `end` 由 `build` 方法所给出。
对于节点 A 的左儿子，有 `start=A.left, end=(A.left + A.right) / 2`。
对于节点 A 的右儿子，有 `start=(A.left + A.right) / 2 + 1, end=A.right`。
如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。
实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间` [start, end] `的线段树，返回这棵线段树的根。

<!-- more -->

线段树(又称区间树), 是一种高级数据结构，他可以支持这样的一些操作:

> - 查找给定的点包含在了哪些区间内
> - 查找给定的区间包含了哪些点

样例:
比如给定start=1, end=6，对应的线段树为：

```c
               [1,  6]
             /        \
      [1,  3]           [4,  6]
      /     \           /     \
   [1, 2]  [3,3]     [4, 5]   [6,6]
   /    \           /     \
[1,1]   [2,2]     [4,4]   [5,5]
```

### 线段树结构的定义

```c
Definition of SegmentTreeNode:
  class SegmentTreeNode {
  public:
      int start, end;
      SegmentTreeNode *left, *right;
      SegmentTreeNode(int start, int end) {
          this->start = start, this->end = end;
          this->left = this->right = NULL;
      }
  }
```

### 线段树的构造

```c
class Solution {
public:
    /**
     *@param start, end: Denote an segment / interval
     *@return: The root of Segment Tree
     */
    SegmentTreeNode * build(int start, int end) {
         // write your code here
        if(start > end)
            return nullptr;
        SegmentTreeNode *node = new SegmentTreeNode(start,end);
        if( start < end ) {
            node->left = build(node->start,(node->start+node->end)/2);
            node->right = build((node->start+node->end)/2+1,node->end);
        }
        return node;
    }
};
```

自底向上构造线段树[online judge](http://lintcode.com/zh-cn/problem/segment-tree-build-ii/)

```c
 SegmentTreeNode * build(vector<int> A) {
        // write your code here
        if (A.size() <= 0) {
            return nullptr;
        }
        return build(0, A.size() - 1, A);
    }
    
    SegmentTreeNode * build(int start, int end, vector<int> &nums) {
        // write your code here
        if (start > end) {
            return nullptr;
        }
        SegmentTreeNode *root = new SegmentTreeNode(start, end, 0);
        if (start != end) {
            root->left = build(start, (start + end) / 2, nums);
            root->right = build((start + end) / 2 + 1, end, nums);
            root->max = max(root->left->max, root->right->max);
        }
        else {
            root->max = nums[start];
        }
        return root;
    }
```

### 线段树的查询

```c
class Solution {
public:
    /**
     *@param root, start, end: The root of segment tree and
     *                         an segment / interval
     *@return: The maximum number in the interval [start, end]
     */
    int query(SegmentTreeNode *root, int start, int end) {
        // write your code here
        // 区间比根区间还大的情况
        if(start <= root->start && end >= root->end){
            return root->max;
        }
        //如果左边界已经大于等于又边界  或者  右边界已经大于等于左边界， 则不存在的这样的区域
        //返回不影响计算最大值的数字
        if(start>root->end || end < root->start){
            return 0;
        }

        int ll = query(root->left,start,end);
        int rr = query(root->right,start,end);
        return max(ll,rr);

    }
};
```

### 线段树的更新

```c
void modify(Node *root, int idx){
        if (root == NULL)
        {
            return;
        }
        if (root->start == root->end && root->start == idx)
        {
            ++(root->cnt);
            return;
        }
        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= idx)
        {
            modify(root->left, idx);
        }
        else
        {
            modify(root->right, idx);
        }
        root->cnt = root->left->cnt + (root->right ? root->right->cnt : 0);
    }
```

### 线段树的应用

#### 统计前面比自己大的数有多少个

使用线段树存储每个区间有多少个数字。

```c
#include <bits/stdc++.h>

using namespace std;

class Node
{
public:
    Node(int _start, int _end) :
            start(_start), end(_end), left(nullptr), right(nullptr),
            cnt(0) {}

    int start, end;
    Node *left, *right;
    int cnt;
};

Node *build(int start, int end)
{
    if (start > end)
    {
        return NULL;
    }
    if (start == end)
    {
        return new Node(start, end);
    }

    int mid = start + ((end - start) >> 1);

    Node *root = new Node(start, end);
    root->left = build(start, mid);
    root->right = build(mid + 1, end);

    return root;
}

void modify(Node *root, int idx){
    if (root == NULL)
    {
        return;
    }

    if (root->start == root->end && root->start == idx)
    {
        ++(root->cnt);
        return;
    }

    int mid = root->start + ((root->end - root->start) >> 1);
    if (mid >= idx)
    {
        modify(root->left, idx);
    }
    else
    {
        modify(root->right, idx);
    }

    root->cnt = root->left->cnt + (root->right ? root->right->cnt : 0);
}

int query(Node *root, int start, int end)
{
    if (root->end < start || root->start > end)
    {
        return 0;
    }
    if (root->start >= start && root->end <= end)
    {
        return root->cnt;
    }

    int mid = root->start + ((root->end - root->start) >> 1);
    if (mid >= end)
    {
        return query(root->left, start, end);
    }
    if (mid < start)
    {
        return query(root->right, start, end);
    }

    int leftRes = query(root->left, start, mid);
    int rightRes = query(root->right, mid + 1, end);

    return leftRes + rightRes;
}

vector<int> countOfSmallerNumberII(vector<int> &A) {
    // write your code here
    int len = A.size();
    Node *root = build(0, 2*len);
    int maxV = INT32_MIN;
    for (int j = 0; j < len; ++j) {
        maxV = max(maxV,A[j]);
    }
    vector<int> res;

    for (int i = 0; i < A.size(); i++)
    {
        int cnt = query(root,A[i] + 1, maxV);
        res.push_back(cnt);
        modify(root, A[i]);
    }

    return res;
}

int main(){
    vector<int> v = {1,2,7,8,5};
    auto re = countOfSmallerNumberII(v);
    return 0;
}

```

#### 统计前面比自己小的数字有多少个

```c
class Node
{
public:
    Node(int _start, int _end) :
            start(_start), end(_end), left(nullptr), right(nullptr),
            cnt(0) {}

    int start, end;
    Node *left, *right;
    int cnt;
};


class Solution {
public:
    /**
      * @param A: An integer array
      * @return: Count the number of element before this element 'ai' is
      *          smaller than it and return count number array
      */
    vector<int> countOfSmallerNumberII(vector<int> &A) {
        // write your code here
        Node *root = build(0, 20000);
        vector<int> res;

        for (int i = 0; i < A.size(); i++)
        {
            int cnt = query(root, 0, A[i] - 1);
            res.push_back(cnt);
            modify(root, A[i]);
        }

        return res;
    }
private:
    Node *build(int start, int end)
    {
        if (start > end)
        {
            return NULL;
        }
        if (start == end)
        {
            return new Node(start, end);
        }

        int mid = start + ((end - start) >> 1);

        Node *root = new Node(start, end);
        root->left = build(start, mid);
        root->right = build(mid + 1, end);

        return root;
    }

    void modify(Node *root, int idx){
        if (root == NULL)
        {
            return;
        }

        if (root->start == root->end && root->start == idx)
        {
            ++(root->cnt);
            return;
        }

        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= idx)
        {
            modify(root->left, idx);
        }
        else
        {
            modify(root->right, idx);
        }

        root->cnt = root->left->cnt + (root->right ? root->right->cnt : 0);
    }

    int query(Node *root, int start, int end)
    {
        if (root->end < start || root->start > end)
        {
            return 0;
        }
        if (root->start >= start && root->end <= end)
        {
            return root->cnt;
        }

        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= end)
        {
            return query(root->left, start, end);
        }
        if (mid < start)
        {
            return query(root->right, start, end);
        }

        int leftRes = query(root->left, start, mid);
        int rightRes = query(root->right, mid + 1, end);

        return leftRes + rightRes;
    }
};
```

## 二叉树相关题目

[二叉树](..\lintcode\tree.md)








