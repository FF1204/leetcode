# 多叉树

记录不是二叉树的其他树型结构

## Trie字典树

### 字典树的实现

```python
class Trie:
    def __init__(self):
        self.root = {}
        self.end = 'END'
    def insert(self, word):
        cur_node = self.root
        for c in word:
            if c not in cur_node:
                cur_node[c] = {}
            cur_node = cur_node[c]
        cur_node[self.end] = True
    def search(self, word):
        current = self.root
        for c in word:
            if c not in current:
                return False
            current = current[c]
        if self.end not in current:
            return False
        return True
    def indexof(self, word):
        # 返回是否是某个单词的前缀
        current = self.root
        for c in word:
            if c not in current:
                return False
            current = current[c]
        if self.end in current:
            current.pop(self.end)
        if len(current) > 0:
            return True
        return False
```

### 字典树的应用

#### 异或（今日头条2017秋招真题）

[异或（今日头条2017秋招真题）](http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3338&konwledgeId=158)

题目描述
									
给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。

								
输入
第一行包含两个整数n, m。
第二行给出n个整数A1, A2, …, An。
样例输入
3 10
6 5 10
输出
输出仅包括一行，即所求的答案。
样例输出
2
时间限制
C/C++语言：1000MS其它语言：3000MS	
内存限制
C/C++语言：65536KB其它语言：589824K

思路：

1. 从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1.
2. 查询每个数字a和m，比较a和m对应的位，有如下情况
   2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位
   2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b < m, 不满足条件，跳过； b = 1, 继续查找下一位
   2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b > m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位
   2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件，

3. 最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。

```c
#include <iostream>
#include <vector>
using namespace std;

struct TrieTree
{
    int count;
    struct TrieTree* next[2]{NULL,NULL};
    TrieTree():count(1){}
};

TrieTree* buildTrieTree(const vector<int>& array)
{
    TrieTree* trieTree = new TrieTree();
    for(int i=0;i<(int)array.size();++i)
    {
        TrieTree* cur = trieTree;
        for(int j=16;j>=0;--j)
        {
            int digit = (array[i] >> j) & 1;
            if(NULL == cur->next[digit])
                cur->next[digit] = new TrieTree();
            else
                ++(cur->next[digit]->count);
            cur = cur->next[digit];
        }
    }
    return trieTree;
}

long long queryTrieTree(TrieTree*& trieTree, const int a, const int m, const int index)
{
    if(NULL == trieTree)
        return 0;

    TrieTree* cur = trieTree;

    for(int i=index;i>=0;--i)
    {
        int aDigit = (a >> i) & 1;
        int mDigit = (m >> i) & 1;

        if(1==aDigit && 1==mDigit)
        {
            if(NULL == cur->next[0])
                return 0;
            cur = cur->next[0];
        }
        else if(0 == aDigit && 1==mDigit)
        {
            if(NULL == cur->next[1])
                return 0;
            cur = cur->next[1];
        }
        else if(1 == aDigit && 0 == mDigit)
        {
            long long val0 =  (NULL == cur->next[0]) ? 0 : cur->next[0]->count;
            long long val1 =  queryTrieTree(cur->next[1],a,m,i-1);
            return val0+val1;
        }
        else if(0 == aDigit && 0 == mDigit)
        {
            long long val0 =  queryTrieTree(cur->next[0],a,m,i-1);
            long long val1 =  (NULL == cur->next[1]) ? 0 : cur->next[1]->count;
            return val0+val1;
        }
    }
    return 0;
}

long long solve(const vector<int>& array, const int& m)
{
    TrieTree* trieTree = buildTrieTree(array);
    long long result = 0;
    for(int i=0;i<(int)array.size();++i)
    {
        result += queryTrieTree(trieTree,array[i],m,16);
    }
    return result /2;
}

int main()
{
    freopen("d:/A.in","r",stdin);
    int n,m;
    while(cin>>n>>m)
    {
        vector<int> array(n);
        for(int i=0;i<n;++i)
            cin>>array[i];
        cout<< solve(array,m) <<endl;
    }
    return 0;
}
```

```c
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>
#include <cmath>
#include <sstream>
#include <iomanip>

using namespace std;
using ll = long long;

const int MAXBIT = 17;

struct trieTree{
    ll count = 0;
    trieTree* next[2] = {nullptr, nullptr};
    trieTree() : count(0){}
    trieTree(int c) : count(c){}
};

trieTree* createTree(const vector<int> &arr){
    trieTree* root = new trieTree(1);
    for (int i = 0; i < arr.size(); ++i) {
        int index = MAXBIT; // int 整形最多32位
        trieTree* cur = root;
        while(index >= 0){
            int digit = (arr[i] >> index) & 1; // 从低位到高位第index+1位的值
            if(cur->next[digit] == nullptr){
                cur->next[digit] = new trieTree(1);
            }else{
                cur->next[digit]->count ++;
            }
            cur = cur->next[digit];
            index--;
        }
    }
    return root;
}
/**
 * 查询trie树中有多少个数字满足a^b>m
 * @param root
 * @param a
 * @param m
 * @param index
 * @return
 */
ll queryTree(trieTree* root,int a, int m, int index){
    if(root == nullptr) return 0;
    for (int i = index; i >= 0; --i) {
        int aDigit = (a >> i) & 1;
        int mDigit = (m >> i) & 1;
        if(aDigit == 0 && mDigit == 0){
            ll v0 = 0 , v1 = 0;
            if(root->next[1] != nullptr){
                v0 = root->next[1]->count;
            }
            v1 = queryTree(root->next[0],a,m,i-1);
            return v0 + v1;
        }else if(aDigit == 0 && mDigit == 1){
            if(root->next[1] == nullptr) return 0;
            return queryTree(root->next[1],a,m,i-1);
        }else if(aDigit == 1 && mDigit == 0){
            ll v0 = 0 , v1 = 0;
            if(root->next[0] != nullptr){
                v0 = root->next[0]->count;
            }
            v1 = queryTree(root->next[1],a,m,i-1);
            return v0 + v1;
        }else if(aDigit == 1 && mDigit == 1){
            if(root->next[0] == nullptr) return 0;
            return queryTree(root->next[0],a,m,i-1);
        }else{
            cout<<"error"<<endl;
        }
    }
    return 0;
}
ll solve(vector<int> &v, int m){
    trieTree* root = createTree(v);
    ll result = 0;
    for (int i = 0; i < v.size(); ++i) {
        result += queryTree(root,v[i],m,MAXBIT);
    }
    return result / 2;
}

int main(){
    freopen("d:/A.in","r",stdin);
    int n, m ;
    cin >> n >> m;
    vector<int> v(n,0);
    for (int i = 0; i < n; ++i) {
        cin >> v[i];
    }
    cout<<solve(v,m)<<endl;
    return 0;
}

```

#### 统计子目录

[统计子目录](http://hihocoder.com/problemset/problem/1551)

描述
小Hi的电脑的文件系统中一共有N个文件，例如：

/hihocoder/offer22/solutions/p1

/hihocoder/challenge30/p1/test  

/game/moba/dota2/uninstall  

小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：

/hihocoder

/hihocoder/offer22

/hihocoder/offer22/solutions

/hihocoder/challenge30

/hihocoder/challenge30/p1

/game

/game/moba

/game/moba/dota2/

输入
第一行包含一个整数N (1 ≤ N ≤ 10000)  

以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录"/"开始，并且文件名和目录名只包含小写字母和数字。  

对于80%的数据，N个文件的绝对路径长度之和不超过10000  

对于100%的数据，N个文件的绝对路径长度之和不超过500000

输出
一个整数代表不同子目录的数目。

样例输入
3  
/hihocoder/offer22/solutions/p1   
/hihocoder/challenge30/p1/test  
/game/moba/dota2/uninstall
样例输出
8

思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1.

```c
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>
#include <cmath>
#include <sstream>
#include <iomanip>
#include <deque>
#include <stack>

using namespace std;

/*
 * [统计子目录](http://hihocoder.com/problemset/solution/1157194)
 * 
 */
struct trieTree{
    string description;
    vector<trieTree*> sons;
    trieTree() : description(""){}
    trieTree(string &s) : description(s){}
};

/**
 * 层次遍历统计节点数目
 * @param root
 * @return
 */
int countNodes(trieTree* root){
    if(root == nullptr) return 0;
    if(root->sons.empty()) return 1;
    vector<trieTree*> nodes, next;
    nodes.push_back(root);

    int re = 0;
    while(!nodes.empty()){
        for (int i = 0; i < nodes.size(); ++i) {
            next.insert(next.end(),nodes[i]->sons.begin(),nodes[i]->sons.end());
        }
        re += nodes.size();
        nodes = next;
        next.clear();
    }
    return re;
}
/**
 * 递归遍历节点数目
 * @param root
 * @return
 */
int countNode2(trieTree *root){
    if(root == nullptr) return 0;
    if(root->sons.empty()) return 1;
    int re = 1;
    for (int i = 0; i < root->sons.size(); ++i) {
        re += countNode2(root->sons[i]);
    }
    return re;
}
vector<string> splitString(const string &s){
    vector<string> re;
    if(s.empty()) return re;
    size_t index1 = 0;
    size_t index2 = 1;
    while(s.find('/',index2) != -1){
        index2 = s.find('/',index1+1);
        re.push_back(s.substr(index1+1,index2-index1-1));
        index1 = index2;
        index2++;
    }
    return re;
}

int solve(vector<string> &pathes, int n){
    if(pathes.empty() || n <= 0) return 0;
    int result = 0;
    trieTree *root = new trieTree();
    for (int i = 0; i < n; ++i) {
        vector<string> path = splitString(pathes[i]);
        trieTree *cur = root;
        for (int j = 0; j < path.size(); ++j) {
            if(cur->sons.empty()){
                cur->sons.push_back(new trieTree(path[j]));
                result++;
                cur = cur->sons[0];
            }else{
                int index = cur->sons.size();
                for (int k = 0; k < cur->sons.size(); ++k) {
                    if(cur->sons[k]->description == path[j]){
                        index = k;
                        break;
                    }
                }
                if(index == cur->sons.size()){
                    cur->sons.push_back(new trieTree(path[j]));
                    result++;
                    cur = cur->sons[cur->sons.size()-1];
                }else{
                    cur = cur->sons[index];
                }
            }
        }
    }
    int re = countNode2(root) - 1;
    return result;
}

int main(){
    freopen("d:/A.in","r",stdin);
    int n;
    cin>>n;
    vector<string> pathes(n,"");
    for (int i = 0; i < n; ++i) {
        cin >> pathes[i];
    }
    cout<<solve(pathes,n)<<endl;
    return 0;
}
```

#### 合并子目录

[合并子目录](http://hihocoder.com/problemset/solution/1157744)

描述
小Hi的电脑的文件系统中一共有N个文件，例如：

/hihocoder/offer23/solutions/p1

/hihocoder/challenge30/p1/test  

/game/moba/dota2/uninstall  

经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用'-'连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为：

/hihocoder/offer23-solutions/p1

/hihocoder/challenge30-p1/test

/game-moba-dota2/uninstall

输入
第一行包含一个整数N (1 ≤ N ≤ 10000)  

以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录"/"开始，并且文件名和目录名只包含小写字母和数字。  

对于80%的数据，N个文件的绝对路径长度之和不超过10000  

对于100%的数据，N个文件的绝对路径长度之和不超过500000

输出
对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。

样例输入
3
/hihocoder/offer23/solutions/p1
/hihocoder/challenge30/p1/test
/game/moba/dota2/uninstall
样例输出
/hihocoder/offer23-solutions/p1
/hihocoder/challenge30-p1/test
/game-moba-dota2/uninstall


```c
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>
#include <cmath>
#include <sstream>
#include <iomanip>
#include <deque>
#include <stack>
using namespace std;
/*
 * [统计子目录](http://hihocoder.com/problemset/solution/1157194)
 *
 */
struct trieTree{
    string description;
    vector<trieTree*> sons;
    trieTree() : description(""){}
    trieTree(string &s) : description(s){}
};

vector<string> splitString(string &s){
    vector<string> re;
    if(s.empty()) return re;
    s.push_back('/');
    size_t index1 = 0;
    size_t index2 = 1;
    while(s.find('/',index2) != -1){
        index2 = s.find('/',index1+1);
        re.push_back(s.substr(index1+1,index2-index1-1));
        index1 = index2;
        index2++;
    }
    return re;
}

trieTree* createTree(vector<string> &pathes){
    if(pathes.empty()) return 0;
    int result = 0;
    trieTree *root = new trieTree();
    for (int i = 0; i < pathes.size(); ++i) {
        vector<string> path = splitString(pathes[i]);
        trieTree *cur = root;
        for (int j = 0; j < path.size(); ++j) {
            if(cur->sons.empty()){
                cur->sons.push_back(new trieTree(path[j]));
                result++;
                cur = cur->sons[0];
            }else{
                int index = cur->sons.size();
                for (int k = 0; k < cur->sons.size(); ++k) {
                    if(cur->sons[k]->description == path[j]){
                        index = k;
                        break;
                    }
                }
                if(index == cur->sons.size()){
                    cur->sons.push_back(new trieTree(path[j]));
                    result++;
                    cur = cur->sons[cur->sons.size()-1];
                }else{
                    cur = cur->sons[index];
                }
            }
        }
    }
    return root;
}

trieTree* reduceTree(trieTree* root){
    trieTree* re = root;
    if(root->sons.empty()) return root;
    if(root->sons.size() >= 2){
        for (int i = 0; i < root->sons.size(); ++i) {
            reduceTree(root->sons[i]);
        }
    }
    if(root->sons.size() == 1){
        trieTree* next = root->sons[0];
        if(next->sons.empty()){
//            root->description = root->description + "-";
//            root->description = root->description + next->description;
//            root->sons.clear();
            return root;
        }
        root->sons.clear();
        for (int i = 0; i < next->sons.size(); ++i) {
            root->sons.push_back(next->sons[i]);
        }
        root->description = root->description + "-";
        root->description = root->description + next->description;
        reduceTree(root);
    }
    return re;
}

void printTree(trieTree* root,string out){
    if(nullptr == root) return;
    out += root->description + "/";
    if(root->sons.empty()){
        if(out.find_last_of('/') == out.size() - 1){
            out.erase(out.size()-1);
        }
        cout<<out<<endl;
    }else{
        for (int i = 0; i < root->sons.size(); ++i) {
            printTree(root->sons[i],out);
        }
    }
}
void solve(vector<string> &pathes, int n){
    int result = 0;
    trieTree* root = createTree(pathes);
    trieTree* reduced = reduceTree(root);
    string out = "";
    printTree(reduced,out);
}

int main(){
    freopen("d:/A.in","r",stdin);
    int n;
    cin>>n;
    vector<string> pathes(n,"");
    for (int i = 0; i < n; ++i) {
        cin >> pathes[i];
    }
    solve(pathes,n);
    return 0;
}

```

## 一般树

学习树结构的时候，做了大量二叉树的题目，了解了二叉树的表示结构和各种操作。但是当遇到普通的树的时候，一时竟不知道如何表示。其实树就是没有环的图。所以用来表示图的两种方法都可以用来表示一般的树结构。

### 表示

**邻接表**

用一个二维的数组(或者链表)表示每个节点的相邻的节点有哪些。

**邻接矩阵**

用一个矩阵表示哪两个节点之间直接相连。

### 应用

#### 无根树化为有根树

将一棵树转换成以其中某个节点为根的树。

[hihocoder 1542](http://hihocoder.com/problemset/problem/1542)

```c
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1005;

vector<int> v[maxn];

int n,rt;

int par[maxn];

void dfs(int x,int p)
{
    par[x] = p;
    for(int i=0;i<v[x].size();i++)
    {
        int toit = v[x][i];
        if(toit!=p)
            dfs(toit,x);
    }
}
int main()
{
    cin >> n >> rt;
    int a, b;
    for(int i=1;i<n;i++)
    {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    dfs(rt,0);
    for(int i=1;i<=n;i++)
        cout << par[i] << (i==n?'\n':' ');
    
    return 0;
}
```

## 霍夫曼编码

霍夫曼编码是一种无损编码方法，它是无损编码方案中最优的，基本思想是给出现频率高的字符以较短的编码，给出现频率低的字符以长的编码。本文将介绍霍夫曼编码的算法步骤和具体实现。

<!--more-->

### 二叉霍夫曼编码

**前缀码**： 没有任何一个编码是其他编码的前缀，这样的一套编码体系叫做前缀码。例如a的编码是010，那么不会存在编码是0，01，0101，0100，010**的字符。前缀码确保了解码时的唯一性。

霍夫曼编码的算法步骤：
1. 统计每个字符出现的频率，按照频率从大到小排序。
2. 找到出现频率最小的两个字符，把这两个字符作为左右孩子，添加一个节点作为它们共同的父亲节点，父亲节点的值是这两个字符频率的和。
3. 重复步骤2直到总概率为1为之。
4. 以上步骤构造了一颗二叉树，二叉树根的概率是1.从根开始，递归的标记每个节点，左孩子标记为0，右孩子标记为1，直到到达叶节点。
5. 从跟出发到每个叶节点经过的0--1路径就是该字符的编码。

下面看一个具体的例子：
假设一个文件中只包含a,b,c,d,e,f六种字符，它们的出现频率如下表所示：

|        | a   | b  | c  | d  | e |f |
|--------| --  | -- | -- | -- | --|--|
| 出现次数| 45 | 13 | 12 | 16  |9 | 5 |
| 出现频率|0.45|0.13|0.12|0.16|0.09|0.05|

第一步，找到频率最小的两个，应该是e,f,我们把e和f的根记作ef，这个时候构造了一个二叉树，二叉树的根是ef,频率是(9+5)/100 = 0.14.
![](img\2017-05-06_230648.png)
第二步，用ef代替e和f之后，继续寻找最小的两个节点，这个时候是b,c,我们把b和c的根记作bc,这个bc的频率是(12+13)/100 = 0.25.
![](img\2017-05-06_230917.png)
第三步，继续寻找频率最低的节点，这个时候是d和ef. 我们把d和ef的根记作def,它的频率是(16+14)/100 = 0.3.
![](img\2017-05-06_231330.png)
第四步，继续寻找频率最小的两个值合并，这个时候是bc和def,我们记作bcdef,它的频率是0.55.
![](img\2017-05-06_231549.png)
第五步，继续寻找频率最小的两个值合并，这个时候只剩下两个值了，就是a和bcde,它们和的频率是1.
![](img\2017-05-06_231913.png)
可以看到，我们最终形成了一颗二叉树，调整一下位置，使之更好看一些。编号之后的情况是这个样子：
![](img\2017-05-06_232520.png)
从中可以得到每个字符的编码：

|a|b|c|d|e|f|
|--|--|--|--|--|--|
|00|0100|0101|0111|01100|01101|

这就是整个霍夫曼编码过程。除了使用二进制编码，其实还可以使用多种不同的进制编码，只要扩展分支的数目就可以了。

### N叉霍夫曼编码

举例来说，还是上面的例子，如果编码的数字允许使用0，1，2三个数字。那么霍夫曼编码的步骤变为：

1. 设字符数量为K，则第一次选择num = `K-2*[(K-1)/2]`,[]代表下取整的意思。这里K=6，所以第一次寻找2个频率最低的字符，e,f.如果num=0,取2，如果num=1,取3.
2. 把找出来的字符的概率合并作为新的一项加入到队列中，原来的删掉，继续用1中的方法寻找直到最后剩下三个为止。

具体到这个问题，具体的过程为：
![](img\2017-05-06_235322.png)
![](img\2017-05-06_235547.png)
![](img\2017-05-06_235729.png)
![](img\2017-05-07_000144.png)
这个时候，得到的最优编码是：

|a|d|c|b|e|f|
|--:|--:|--:|--:|--:|--:|
|0|2|10|12|110|111|

于此，我们可以很容易的推广到N叉霍夫曼编码，思想是一样的，都是贪心法和前缀码。

### 二叉哈夫曼编码的实现

下面给出二叉霍夫曼编码的C++实现的版本：

```c
struct Node{
    int label; // 节点的编码， 0 或者 1
    char c; // 节点表示的字符
    Node* left;
    Node* right;
    Node() : label(-1),left(nullptr), right(nullptr){}
    Node(char cc) : label(-1), c(cc),left(nullptr), right(nullptr){}
    Node(int la) : label(la),left(nullptr), right(nullptr){}
};
/**
 * 输出字符的编码
 * @param root 
 * @param s 
 * @param re 
 */
void dfs(Node* root,string &s,map<char,string> &re){
    if(!root) return;
    if(!root->left && !root->right){
        re[root->c] = s + to_string(root->label);
        s.clear();
        return;
    }else{
        s += to_string( root->label );
        string s1(s);
        string s2(s);
        if(root->left) dfs(root->left,s1,re);
        if(root->right) dfs(root->right,s2,re);
    }
}
/**
 * 哈夫曼编码
 * @param source 每个字符出现的频率
 * @return  每个字符对应的二进制编码
 */
map<char,string> huff(map<char,double> &source){
    // 1. 初始化数据结构
    multimap<double,Node*> tree;
    for(auto iter : source){
        Node *newNode = new Node(iter.first);
        tree.insert(make_pair(iter.second,newNode));
    }
    // 2. 构建哈夫曼树
    Node* newNode;
    while( tree.size() > 1){
        auto ff = tree.begin();
        auto ss = ++(tree.begin());
        newNode = new Node();
        newNode->left = ff->second;
        ff->second->label = 0; // 左子树编码为0
        newNode->right = ss->second;
        ss->second->label = 1; // 右子树编码为1
        tree.insert(make_pair(ff->first+ss->first,newNode));
        tree.erase(ff);
        tree.erase(ss);
    }
    newNode->label = 0; // 根节点编码为0

    // 3. 输出每个叶子节点的编码
    Node* root = newNode;
    string tmp = "";
    map<char,string> re;
    dfs(root,tmp,re);
    return re;
}
```

```python
import heapq

class Node:
    def __init__(self, left=None, right=None, char=None, double):
        self.left = left
        self.right = right 
        self.char = char
        self.double = double
def huffman(c):
    """
    c: (double, char) 每个char出现的频率
    """
    heap = heapq.heapify()
    for char, double in c:
        node = Node(char=char, double=double)
        heapq.heappush(heap, [double, node])
    while len(heap) > 1:
        a = heapq.heappop(heap)
        b = heaq.heappop(heap)
        node = Node(double=a[0]+b[0])
        node.left = a
        node.right = b
        heapq.heappush(heap, [a[0]+b[0], node])
    root = heap[0]
    return root
```
